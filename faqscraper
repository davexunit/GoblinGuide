#!/usr/bin/python

import curses
import sys
import fnmatch
import urllib
import subprocess
import scrape

def clear(stdscr):
	stdscr.clear()
	stdscr.border(0)

def get_input(stdscr, y, x, prompt, strlen):
	stdscr.addstr(y, x, prompt)
	stdscr.refresh()
	curses.echo()
	user_input = stdscr.getstr(y, x + len(prompt), strlen)
	curses.noecho()
	return user_input

def menu(stdscr, y, x, height, width, title, choices):
	'''Displays a menu for the user to choose a game from a list of search results.
	'''
	choice = 0
	# The menu list will be in a pad
	pad = curses.newpad(len(choices), width)
	# Display the title
	clear(stdscr)
	stdscr.addstr(y, (width - len(title)) / 2, title, curses.A_BOLD)
	stdscr.refresh()
	# Adjust y value for the pad
	y += 1
	# Loop while responding to keyboard input
	while True:
		# Display all search results
		for i, c in enumerate(choices):
			if i == choice:
				flag = curses.A_REVERSE
			else:
				flag = 0
			pad.addstr(i, 1, c, flag)
		# Display menu entry and center the pad on the selected item, clamping to the top and bottom of the pad
		pad.refresh(min(len(choices) - height + 1, max(0, choice - height / 2)), 0, y, x, height, width)
		# Get a key prss
		c = stdscr.getch()
		# Quit on q
		if c == ord('q'):
			sys.exit(0)
		# Scroll up/down list
		elif c == curses.KEY_DOWN or c == ord('j'):
			choice += 1
			choice = min(len(choices) - 1, choice)
		elif c == curses.KEY_UP or c == ord('k'):
			choice -= 1
			choice = max(0, choice)
		# Page up/down
		elif c == curses.KEY_NPAGE:
			choice += height - 1
			choice = min(len(choices) - 1, choice)
		elif c == curses.KEY_PPAGE:
			choice -= height - 1
			choice = max(0, choice)
		# Home/End
		elif c == curses.KEY_HOME:
			choice = 0
		elif c == curses.KEY_END:
			choice = len(choices) - 1
		# Break out of loop on enter key which will bring the user to the FAQ screen
		elif c == ord('\n'):
			break
	
	return choice

def search(screen):
	clear(screen)
	search = get_input(screen, 1, 1, 'Enter game search: ', 60)
	choose_search_result(screen, scrape.game_search(search))

def choose_search_result(stdscr, results):
	'''Displays a menu for the user to choose a game from a list of search results.
	'''
	# Make the strings for menu choices
	choices = []
	for result in results:
		choices.append('%s - %s' % result[:2])
	# Get width and height of window
	height, width = stdscr.getmaxyx()
	# Prompt user with a menu to choose the search result they want
	choice = menu(stdscr, 1, 1, height - 2, width - 2, 'Search Results', choices)
	# Move to the FAQs display screen
	choose_faq(stdscr, results[choice][2])

def choose_faq(stdscr, faq_url):
	'''Displays a menu to choose a FAQ for a game
	Assumes that faq_url is a url to the correct page
	'''
	# Scrape the FAQs page
	faqs = scrape.faqs(faq_url)
	# Make the strings for menu choices
	choices = []
	for faq in faqs:
		choices.append('%s - %s - %s - %s - %s' % faq[:5])
	# Get width and height of window
	height, width = stdscr.getmaxyx()
	# Prompt user with a menu to choose the search result they want
	choice = menu(stdscr, 1, 1, height - 2, width - 2, 'FAQs', choices)
	link = faqs[choice][5]
	# Most of the time the FAQ links are html files that need one more step of scraping to get the plain text...
	# ... but sometimes the link goes directly to the text file
	# So, that's what this little line of code checks for
	if not fnmatch.fnmatch(link, '*.txt'):
		link = scrape.plaintext_faq(faqs[choice][5])
	read_faq(link)

def read_faq(doc_url):
	'''Opens doc_url, downloads the FAQ, and opens it in the system default editor
	'''
	urllib.urlretrieve(doc_url, '/tmp/faq.txt')
	subprocess.call(['vim', '/tmp/faq.txt'])

if __name__ == '__main__':
	while True:
		# Initializes curses nicely, undoing all changes if the program crashes
		curses.wrapper(search)
